{"version":3,"file":"moa.min.js","sources":["Moa.js"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * Created with WebStorm.\r\n * Project: MoaJs\r\n * User: Sergii Danilov\r\n * Date: 10/31/13\r\n * Time: 6:10 PM\r\n */\r\n/*global define:true, module:true*/\r\n/**\r\n * @module Moa\r\n *\r\n * @desc MoaJs micro library for easiest implementation of prototype inheritance,\r\n * closure for base prototype, mixins, static methods and mixins,\r\n * simple declaration for singleton behavior of type in JavaScript.\r\n * MoaJs contains IoC container for resolving declared types as\r\n * field or constructor injection to instance\r\n */\r\n(function () {\r\n    \"use strict\";\r\n    if (!Object.create) {\r\n        Object.create = (function () {\r\n            function F() {}\r\n            return function (o) {\r\n                if (arguments.length !== 1) {\r\n                    throw new Error('Object.create implementation only accepts one parameter.');\r\n                }\r\n                F.prototype = o;\r\n                return new F();\r\n            };\r\n        }());\r\n    }\r\n    var undef,\r\n        map = {},\r\n        mixins = {},\r\n        extend = function (target, source) {\r\n            var prop;\r\n            if (source) {\r\n                for (prop in source) {\r\n                    if (source.hasOwnProperty(prop)) {\r\n                        target[prop] = source[prop];\r\n                    }\r\n                }\r\n                //Some Object methods are not enumerable on Internet Explorer\r\n                target.toString = source.toString;\r\n                target.valueOf = source.valueOf;\r\n                target.toLocaleString = source.toLocaleString;\r\n            }\r\n            return target;\r\n        },\r\n        fastExtend = function (target, source) {\r\n            var prop;\r\n            for (prop in source) {\r\n                target[prop] = source[prop];\r\n            }\r\n            return target;\r\n        },\r\n        throwWrongParamsErr = function (method, param) {\r\n            var msg = 'Wrong parameters in ' + method;\r\n            if (param) {\r\n                msg = 'Wrong parameter ' + param + ' in ' + method;\r\n            }\r\n            throw new Error(msg, 'Moa');\r\n        },\r\n        throwWrongType = function (obj, extendType, isMixin) {\r\n            var type = 'Type ';\r\n            if (obj === undef) {\r\n                if (isMixin === true) {\r\n                    type = 'Mixin type ';\r\n                }\r\n                throw new Error(type + extendType + ' not found', 'Moa');\r\n            }\r\n        },\r\n        addMixins = function ($proto, $mixin) {\r\n            var prop,\r\n                value,\r\n                MixFn;\r\n            for (prop in $mixin) {\r\n                value = $mixin[prop];\r\n                MixFn = mixins[value];\r\n                throwWrongType(MixFn, value, true);\r\n                MixFn.call($proto);\r\n                $proto[prop] = new MixFn();\r\n            }\r\n            return $proto;\r\n        },\r\n        build = function (type, base, definition) {\r\n            var basetype,\r\n                $staticMixin,\r\n                $single = definition.$single,\r\n                $static = definition.$static,\r\n                $mixin = definition.$mixin,\r\n                $ctor = definition.$ctor,\r\n                $di = definition.$di,\r\n                $base = {};\r\n            if ($ctor !== undef) {\r\n                delete definition.$ctor;\r\n            } else {\r\n                $ctor = function () {};\r\n            }\r\n            delete definition.$single;\r\n            delete definition.$static;\r\n            delete definition.$mixin;\r\n            delete definition.$extend;\r\n            if ($static !== undef) {\r\n                $staticMixin = $static.$mixin;\r\n                if ($staticMixin !== undef) {\r\n                    delete $static.$mixin;\r\n                    addMixins($ctor, $staticMixin);\r\n                }\r\n                extend($ctor, $static);\r\n            }\r\n            if ($mixin !== undef) {\r\n                definition = extend(addMixins({}, $mixin), definition);\r\n            }\r\n            if (base !== undef) {\r\n                basetype = base.$type;\r\n                definition = extend(Object.create(base.$ctor.prototype), definition);\r\n            }\r\n            definition.getType = function () {\r\n                return type;\r\n            };\r\n            extend($base, definition);\r\n            $ctor.prototype = definition;\r\n            $ctor.prototype.constructor = $ctor;\r\n            if ($single !== undef && $single === true) {\r\n                (function () {\r\n                    var instance = new $ctor();\r\n                    $ctor = function () {\r\n                        return instance;\r\n                    };\r\n                    $ctor.getInstance = function () {\r\n                        return instance;\r\n                    };\r\n                }());\r\n            }\r\n            $base.$ctor = $ctor;\r\n            return {\r\n                $type: type,\r\n                $basetype: basetype,\r\n                $mixin: $mixin,\r\n                $di: $di,\r\n                $ctor: $ctor,\r\n                $base: $base\r\n            };\r\n        },\r\n        resolveDeclaration = function (type, diConfiguration, owner) {\r\n            var configurationProperty, configurationValue, configurationValueType,\r\n                typeObj, propFlag = false;\r\n            diConfiguration = diConfiguration || {};\r\n            if (!diConfiguration.$current) {\r\n                diConfiguration.$current = type;\r\n            }\r\n            for (configurationProperty in diConfiguration) {\r\n                configurationValue = diConfiguration[configurationProperty];\r\n                configurationValueType = typeof configurationValue;\r\n                switch (configurationProperty) {\r\n                case '$current':\r\n                    switch (configurationValueType) {\r\n                    case 'string':\r\n                        configurationValue = {\r\n                            type: configurationValue,\r\n                            instance: 'item',\r\n                            lifestyle: 'transient'\r\n                        };\r\n                        break;\r\n                    case 'object':\r\n                        configurationValue.type = type;\r\n                        if (!configurationValue.instance) {\r\n                            configurationValue.instance = 'item';\r\n                        }\r\n                        if (!configurationValue.lifestyle && configurationValue.instance !== 'ctor') {\r\n                            configurationValue.lifestyle = 'transient';\r\n                        }\r\n                        break;\r\n                    default:\r\n                    }\r\n                    break;\r\n                case '$ctor':\r\n                    configurationValue = resolveDeclaration(type, configurationValue, configurationProperty);\r\n                    delete configurationValue.$current;\r\n                    break;\r\n                case '$proto':\r\n                    configurationValue = resolveDeclaration(type, configurationValue, configurationProperty);\r\n                    delete configurationValue.$current;\r\n                    break;\r\n                case '$prop':\r\n                    configurationValue = resolveDeclaration(type, configurationValue, configurationProperty);\r\n                    delete configurationValue.$current;\r\n                    break;\r\n                default:\r\n                    propFlag = true;\r\n                    switch (configurationValueType) {\r\n                    case 'string':\r\n                        typeObj = map[configurationValue];\r\n                        if (typeObj) {\r\n                            if (owner === '$proto') {\r\n                                configurationValue = fastExtend({}, typeObj.$di.$current);\r\n                                configurationValue.lifestyle = 'singleton';\r\n                            } else {\r\n                                configurationValue = typeObj.$di.$current;\r\n                            }\r\n                        }\r\n                        break;\r\n                    case 'object':\r\n                        if (configurationValue.type) {\r\n                            if (configurationValue.instance === 'ctor') {\r\n                                delete configurationValue.lifestyle;\r\n                            } else {\r\n                                if (!configurationValue.instance) {\r\n                                    configurationValue.instance = 'item';\r\n                                }\r\n                                if (!configurationValue.lifestyle) {\r\n                                    configurationValue.lifestyle = 'transient';\r\n                                }\r\n                            }\r\n                        }\r\n                        break;\r\n                    default:\r\n                    }\r\n                }\r\n                if (owner || !propFlag) {\r\n                    diConfiguration[configurationProperty] = configurationValue;\r\n                } else {\r\n                    propFlag = false;\r\n                    if (!diConfiguration.$prop) {\r\n                        diConfiguration.$prop = {};\r\n                    }\r\n                    diConfiguration.$prop[configurationProperty] = configurationValue;\r\n                    delete diConfiguration[configurationProperty];\r\n                }\r\n            }\r\n            return diConfiguration;\r\n        },\r\n        Moa = {\r\n            /**\r\n             * Clear all defined types and mixins\r\n             * @method clear\r\n             */\r\n            clear: function () {\r\n                var clearObj = function (obj) {\r\n                    var prop;\r\n                    for (prop in obj) {\r\n                        delete obj[prop];\r\n                    }\r\n                };\r\n                clearObj(map);\r\n                clearObj(mixins);\r\n            },\r\n            /**\r\n             * Declaration configuration for type\r\n             * @typedef {object} DeclarationConf\r\n             * @property {function} [$ctor] - constructor of type\r\n             * @property {string} [$extend] - inheritable type name\r\n             * @property {DiConf} [$di] - configuration for IoC container\r\n             * @property {object} [$mixin] - literal with mixins declaration\r\n             * @property {object} [$static] - literal with properties and function that applied to constructor\r\n             * @property {boolean} [$single] - setup type as singleton\r\n             */\r\n            /**\r\n             * Declaration configuration for type\r\n             * @typedef {function} DeclarationFn\r\n             * @param {object} $base - prototype of inheritable type with $base.$ctor - constructor of inheritable type\r\n             * @return {DeclarationConf} object that uses $base closure for access to inheritable type implementation constructor and methods\r\n             */\r\n            /**\r\n             * Define new or inherited type\r\n             * @method define\r\n             * @param {string} type - name of type\r\n             * @param {(DeclarationConf|DeclarationFn)} [definition] - see {@link DeclarationConf} or {@link DeclarationFn}.\r\n             * If it is null - delete declared object\r\n             * @return {function} constructor of defined object type\r\n             *\r\n             * @example <caption>Declaration without <code>$base</code> closure</caption>\r\n             * var constructor = Moa.define('baseObj', {\r\n             *      $ctor: function (name) {\r\n             *              this.name = name;\r\n             *          },\r\n             *      getName: function() {\r\n             *          return this.name;\r\n             *      }\r\n             *  });\r\n             *\r\n             * @example <caption>Declaration inheritance and <code>$base</code> closure</caption>\r\n             * var constructor = Moa.define('child', function ($base) {\r\n             *     // $base - containe reference to prototype of 'baseObj'\r\n             *     return {\r\n             *         $extend: 'baseObj',\r\n             *         $ctor: function (name, age) {\r\n             *             this.age = age;\r\n             *             $base.$ctor.call(this, name);\r\n             *         },\r\n             *         getAge: function () {\r\n             *             return this.age;\r\n             *         }\r\n             *     };\r\n             * });\r\n             *\r\n             * @example <caption>Delete type declaration</caption>\r\n             * Moa.define('base', {});     // new type declaration\r\n             * Moa.define('base', null);   // delete type declaration\r\n             *\r\n             * @example <caption>Declaration <code>$base</code> closure</caption>\r\n             * var childItem,\r\n             *     base = Moa.define('base', function ($base) {\r\n             *        // $base - undefined\r\n             *        return {\r\n             *            $ctor: function (name) {\r\n             *                this.name = name;\r\n             *            },\r\n             *            getName: function() {\r\n             *                return this.name;\r\n             *            }\r\n             *        };\r\n             *     }),\r\n             *     child = Moa.define('child', function ($base) {\r\n             *        // $base - reference to 'base' type\r\n             *        return {\r\n             *            $extend: 'base',\r\n             *            $ctor: function (name, age) {\r\n             *                this.age = age;\r\n             *                $base.$ctor.call(this, name);\r\n             *            },\r\n             *            // override base implementation\r\n             *            getName: function() {\r\n             *                return 'Child: ' + $base.getName.call(this);\r\n             *            },\r\n             *            getAge: function () {\r\n             *                return this.age;\r\n             *            }\r\n             *        };\r\n             *    });\r\n             *\r\n             * @example <caption>Using instance</caption>\r\n             * childItem = new child('Pet', 7);\r\n             * childItem.getName(); // 'Child: Pet'\r\n             * childItem.getAge();  // 7\r\n             *\r\n             * @example <caption>Declaration static methods</caption>\r\n             * var baseCtor, item,\r\n             *     strMix = function () {\r\n             *         this.add = function () {\r\n             *             return (this.a.toString() + this.b.toString());\r\n             *         };\r\n             *     }\r\n             *     base = {\r\n             *         $ctor: function () {\r\n             *         },\r\n             *         $static: {\r\n             *             // Also you can declare static mixins in usual way\r\n             *             $mixin: {\r\n             *                 str: 'strMix'\r\n             *             },\r\n             *             getMsg: function () {\r\n             *                 return 'Static!';\r\n             *             },\r\n             *             a: 15,\r\n             *             b: 17\r\n             *         }\r\n             *     };\r\n             * Moa.mixin('strMix', strMix);\r\n             * Moa.define('base', base);\r\n             *\r\n             * @example <caption>Using static methods</caption>\r\n             * baseCtor = Moa.define('base');\r\n             * baseCtor.getMsg(); // 'Static!' - static method\r\n             * baseCtor.add(); // '15' + '17' => '1517' - static mixin\r\n             * Ctor.str.add.call(Ctor); // '1517'\r\n             *\r\n             * @example <caption>Declaration singleton</caption>\r\n             * var itemA, itemB, ItemC,\r\n             *     singeltonConstructor = Moa.define('singleExample', {\r\n             *         $single: true,\r\n             *         $ctor: function () {\r\n             *             this.name = 'Moa';\r\n             *         },\r\n             *         getName: function () {\r\n             *             return this.name;\r\n             *         }\r\n             *     })\r\n             *\r\n             * @example <caption>Using singleton</caption>\r\n             * // Unfortunately it can not have constructor parameters\r\n             * itemA = new singeltonConstructor();\r\n             * itemB = singeltonConstructor();\r\n             * itemC = singeltonConstructor.getInstance();\r\n             * // itemA equal itemB equal itemC\r\n             */\r\n            define: function (type, definition) {\r\n                var mapObj, baseType, base,\r\n                    len = arguments.length;\r\n                switch (len) {\r\n                case 1:\r\n                    mapObj = map[type];\r\n                    throwWrongType(mapObj, type);\r\n                    break;\r\n                case 2:\r\n                    switch (typeof definition) {\r\n                    case 'function':\r\n                        baseType = definition().$extend;\r\n                        if (baseType !== undef) {\r\n                            base = map[baseType];\r\n                            throwWrongType(base, baseType);\r\n                            mapObj = build(type, base, definition(base.$base));\r\n                        } else {\r\n                            mapObj = build(type, undef, definition(undef));\r\n                        }\r\n                        break;\r\n                    case 'object':\r\n                        if (definition !== null) {\r\n                            baseType = definition.$extend;\r\n                            if (baseType !== undef) {\r\n                                base = map[baseType];\r\n                                throwWrongType(base, baseType);\r\n                            }\r\n                            mapObj = build(type, base, definition);\r\n                        } else {\r\n                            delete map[type];\r\n                            return undef;\r\n                        }\r\n                        break;\r\n                    default:\r\n                        throwWrongParamsErr('define', 'definition');\r\n                    }\r\n                    map[type] = mapObj;\r\n                    map[type].$di = resolveDeclaration(type, mapObj.$di);\r\n                    break;\r\n                default:\r\n                    throwWrongParamsErr('define');\r\n                }\r\n                return mapObj.$ctor;\r\n            },\r\n            /**\r\n             * Declaration of dependency injection behavior\r\n             * @typedef {object} InjectionConf\r\n             * @property {string} type - name of type for injection.\r\n             * Not available for $current in {@link DiConf}\r\n             * @property {string} instance - Injected instance.\r\n             * Values: 'item' or 'ctor'. Default value: 'item'.\r\n             * @property {string} lifestyle - Life style for 'item' instance. Not used for 'ctor'.\r\n             * Values: 'transient' or 'singleton'. Default value: 'transient'.\r\n             */\r\n            /**\r\n             * Configuration of dependency injection. Used as $di parameter in type declaration.\r\n             * @typedef {object} DiConf\r\n             * @property {object} [$current] - set default injection behavior for declared type\r\n             * @property {object} [$ctor] - literal declare types that inject to constructor\r\n             * @property {object} [$prop] - literal declare types that inject to instance properties\r\n             * @property {object} [$proto] - literal declare types that inject to prototype of instance properties.\r\n             * BE CAREFUL! It resolved one time after use 'resolve' method and override exist properties and methods in prototype.\r\n             * Resolved properties and methods available in prototype of constructor type for all places where constructor uses ('define' method for example).\r\n             * @property {*} - properties that injected as instance properties. All string values try to resolve as declared types\r\n             * @example\r\n             * {\r\n             *     $ctor: {\r\n             *         fieldA: {\r\n             *             type: 'typeA',\r\n             *             instance: 'item',\r\n             *             lifestyle: 'transient'\r\n             *         },\r\n             *         field: 'typeB'   // try to resolve as 'typeB' otherwise use as a string\r\n             *     },\r\n             *     $prop: {\r\n             *         propA: 'typeA'   // resolved like fieldA to instance field\r\n             *     },\r\n             *     $proto: {\r\n             *         protoProp: {     // resolve constructor of 'typeB' to instance prototype\r\n             *             type: 'typeB',\r\n             *             instance: 'ctor' // if instance is 'item' it has lifestyle as 'singleton'\r\n             *         }\r\n             *     },\r\n             *     propC: {             // resolve the same instance of 'typeC' for every instance in $prop literal\r\n             *         type: 'typeA',\r\n             *         instance: 'item',\r\n             *         lifestyle: 'singleton'\r\n             *     },\r\n             *     prop: 2315           // copy number field to resolved instance\r\n             * }\r\n             */\r\n            /**\r\n             * Resolve new instance of type with field and constructor injection.\r\n             * Resolving logic based on $di configuration of type declaration.\r\n             * @method resolve\r\n             * @param {string} type - name of type\r\n             * @param {object} [paramsObj] - constructor parameter for resolved type\r\n             * @return {object} instance of type\r\n             */\r\n            resolve: function (type, paramsObj) {\r\n                var item,\r\n                    //depthRecursion = 64, cntRecursion = 0,\r\n                    mapObj = map[type],\r\n                    len = arguments.length,\r\n                    fnResolveListConf = function (target, config, fnResolveObjConf) {\r\n                        var prop, propValue;\r\n                        for (prop in config) {\r\n                            propValue = config[prop];\r\n                            if (typeof propValue === 'object') {\r\n                                target[prop] = fnResolveObjConf(propValue, fnResolveListConf);\r\n                            } else {\r\n                                target[prop] = propValue;\r\n                            }\r\n                        }\r\n                        return target;\r\n                    },\r\n                    createItem = function (declaration, obj, fnResolveObjConf, cParams) {\r\n                        var item, conf, proto;\r\n                        cParams = cParams || {};\r\n                        conf = declaration.$ctor;\r\n                        if (conf) {\r\n                            cParams = fnResolveListConf(cParams, conf, fnResolveObjConf);\r\n                        }\r\n                        conf = declaration.$proto;\r\n                        if (conf) {\r\n                            if (!conf.resolved) {\r\n                                proto = fnResolveListConf({}, conf, fnResolveObjConf);\r\n                                fastExtend(obj.$ctor.prototype, proto);\r\n                                conf.resolved = true;\r\n                            }\r\n                        }\r\n                        item = new obj.$ctor(cParams);\r\n                        conf = declaration.$prop;\r\n                        if (conf) {\r\n                            item = fnResolveListConf(item, conf, fnResolveObjConf);\r\n                        }\r\n                        return item;\r\n                    },\r\n                    fnResolveObjConf = function (declaration, ctorParams) {\r\n                        var resolvedObj,\r\n                            current = declaration.$current;\r\n                        /*==========================================================\r\n                        if you have problem with IoC, just uncomment 3 rows bellow\r\n                        and second row in 'resolve' function\r\n                        =========================================================*/\r\n//                        cntRecursion += 1;\r\n//                        if (cntRecursion > depthRecursion) {\r\n//                            throw new Error('Loop of recursion', 'moa');\r\n//                        }\r\n                        if (current) {\r\n                            resolvedObj = map[current.type];\r\n                        } else {\r\n                            current = declaration;\r\n                            resolvedObj = map[current.type];\r\n                            if (resolvedObj) {\r\n                                declaration = resolvedObj.$di;\r\n                            } else {\r\n                                return declaration;\r\n                            }\r\n                        }\r\n                        switch (current.instance) {\r\n                        case 'item':\r\n                            switch (current.lifestyle) {\r\n                            case 'transient':\r\n                                item = createItem(declaration, resolvedObj, fnResolveObjConf, ctorParams);\r\n                                break;\r\n                            case 'singleton':\r\n                                if (!current.item) {\r\n                                    current.item = createItem(declaration, resolvedObj, fnResolveObjConf, ctorParams);\r\n                                }\r\n                                item = current.item;\r\n                                break;\r\n                            default:\r\n                                throwWrongParamsErr('resolve', type + '::$di::$current::lifestyle');\r\n                            }\r\n                            break;\r\n                        case 'ctor':\r\n                            item = resolvedObj.$ctor;\r\n                            break;\r\n                        default:\r\n                            throwWrongParamsErr('resolve', type + '::$di::$current::instance');\r\n                        }\r\n                        return item;\r\n                    };\r\n                if (len !== 1 && len !== 2) {\r\n                    throwWrongParamsErr('resolve');\r\n                }\r\n                throwWrongType(mapObj, type);\r\n                item = fnResolveObjConf(mapObj.$di, paramsObj);\r\n                return item;\r\n            },\r\n            /**\r\n             * Declare mixin\r\n             * @method mixin\r\n             * @param {string} mixType - name of mixin type\r\n             * @param {function} definition - implementation of behavior for mixin.\r\n             * If it is null - delete declared mixin\r\n             *\r\n             * @example <caption>Declaration mixin</caption>\r\n             * var numMix = function () {\r\n             *      this.add = function () {\r\n             *          return (this.a + this.b);\r\n             *      };\r\n             *      this.sub = function () {\r\n             *         return (this.a - this.b);\r\n             *      };\r\n             *      this.mul = function () {\r\n             *          return (this.a * this.b);\r\n             *      };\r\n             * };\r\n             * Moa.mixin('numMix', numMix);\r\n             *\r\n             * @example <caption>Using mixin</caption>\r\n             * var item, Ctor,\r\n             *     base = {\r\n             *     $ctor: function (a, b) {\r\n             *         this.a = a;\r\n             *         this.b = b;\r\n             *     },\r\n             *     $mixin: {\r\n             *         nummix: 'numMix'\r\n             *     },\r\n             *     mul: function () {\r\n             *         return 'a*b=' + this.nummix.mul.call(this);\r\n             *     }\r\n             * };\r\n             * Ctor = Moa.define('base', base);\r\n             * item = new Ctor(3, 4);\r\n             * item.add(); // 7\r\n             * item.mul(); // 'a*b=12'\r\n             *\r\n             * @example <caption>Multiple mixins example</caption>\r\n             * var Ctor, item,\r\n             *     base = {\r\n             *         $ctor: function (a, b) {\r\n             *             this.a = a;\r\n             *             this.b = b;\r\n             *         },\r\n             *         $mixin: {\r\n             *             num: 'numMix',\r\n             *             str: 'strMix'\r\n             *         }\r\n             *     },\r\n             *     numMix = function () {\r\n             *         this.add = function () {\r\n             *             return (this.a + this.b);\r\n             *         };\r\n             *     },\r\n             *     strMix = function () {\r\n             *         this.add = function () {\r\n             *             return (this.a.toString() + this.b.toString());\r\n             *         };\r\n             *     };\r\n             * Moa.mixin('numMix', numMix);\r\n             * Moa.mixin('strMix', strMix);\r\n             * Ctor = Moa.define('base', base);\r\n             * item = new Ctor(10, 12);\r\n             * item.add(); // '1012'\r\n             * item.num.add.call(item); // 22\r\n             * item.str.add.call(item); //'1012'\r\n             *\r\n             * @example <caption>Delete mixin declaration</caption>\r\n             * Moa.mixin('mix', function () {});    // new mixin declaration\r\n             * Moa.mixin('mix', null);    // delete mixin declaration\r\n             *\r\n             * @example <caption>Static mixin declaration</caption>\r\n             * var base = {\r\n             *     $mixin: {\r\n             *         num: 'numMix'\r\n             *     },\r\n             *     $static: {\r\n             *         $mixin: {\r\n             *             str: 'strMix'\r\n             *         }\r\n             *     }\r\n             * }\r\n             */\r\n            mixin: function (mixType, definition) {\r\n                if (definition !== null) {\r\n                    if (typeof definition !== 'function') {\r\n                        throwWrongParamsErr('mixin', 'definition');\r\n                    }\r\n                    mixins[mixType] = definition;\r\n                } else {\r\n                    delete mixins[mixType];\r\n                }\r\n            },\r\n            /**\r\n             * Get all available types and mixins\r\n             * @method getRegistry\r\n             * @return {object} object with arrays declared types and mixins\r\n             * @example\r\n             * {\r\n             *   type: ['type1', 'type2', ...],\r\n             *   mixin: ['mixin1', 'mixin2', ...]\r\n             * }\r\n             */\r\n            getRegistry: function () {\r\n                var iterate = function (obj) {\r\n                        var prop, arr = [];\r\n                        for (prop in obj) {\r\n                            arr.push(prop);\r\n                        }\r\n                        return arr;\r\n                    };\r\n                return {\r\n                    type: iterate(map),\r\n                    mixin: iterate(mixins)\r\n                };\r\n            },\r\n            /**\r\n             * Get internal information about type\r\n             * @method getTypeInfo\r\n             * @param {string} type - name of type\r\n             * @return {object} object with information about type,\r\n             * base type, applied mixins and configuration for dependency injection\r\n             * @example\r\n             * {\r\n             *      $type: 'child',\r\n             *      $basetype: 'base',\r\n             *      $mixin: {\r\n             *          mixA: 'mixinA',\r\n             *          mixB: 'mixinB'\r\n             *      },\r\n             *      $di: {\r\n             *          $current: {\r\n             *              type: 'child',\r\n             *              instance: 'item',\r\n             *              lifestyle: 'transient'\r\n             *          },\r\n             *          $prop: {\r\n             *              a: {\r\n             *                  type: 'base',\r\n             *                  instance: 'item',\r\n             *                  lifestyle: 'transient'\r\n             *              },\r\n             *              b: 'child'\r\n             *          }\r\n             *      }\r\n             *  }\r\n             */\r\n            getTypeInfo: function (type) {\r\n                var result,\r\n                    mapObj = map[type];\r\n                throwWrongType(mapObj, type);\r\n                result = extend({}, mapObj);\r\n                delete result.$ctor;\r\n                delete result.$base;\r\n                delete result.$di;\r\n                result.$di = JSON.parse(JSON.stringify(mapObj.$di));\r\n                return result;\r\n            }\r\n        };\r\n    // Return as AMD module or attach to head object\r\n    if (typeof define !== 'undefined') {\r\n        define('Moa',[], function () { return Moa; });\r\n    } else if (typeof window !== 'undefined') {\r\n        window.Moa = Moa;\r\n    } else {\r\n        module.exports = Moa;\r\n    }\r\n}());\n"]}