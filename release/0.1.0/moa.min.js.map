{"version":3,"file":"moa.min.js","sources":["Moa.js"],"names":[],"mappings":"CAYA,WAEA,OAAA,SACA,OAAA,OAAA,WACA,QAAA,MACA,MAAA,UAAA,GACA,GAAA,IAAA,UAAA,OACA,KAAA,IAAA,OAAA,2DAGA,OADA,GAAA,UAAA,EACA,GAAA,OAIA,IAAA,GACA,EAAA,WACA,EAAA,SACA,EAAA,YACA,KACA,KACA,EAAA,SAAA,EAAA,GACA,GAAA,EACA,KAAA,IAAA,GACA,EAAA,eAAA,KACA,EAAA,GAAA,EAAA,GAOA,OAHA,GAAA,SAAA,EAAA,SACA,EAAA,QAAA,EAAA,QACA,EAAA,eAAA,EAAA,eACA,GAEA,EAAA,SAAA,EAAA,GACA,GAAA,GAAA,uBAAA,CAIA,MAHA,KACA,EAAA,mBAAA,EAAA,OAAA,GAEA,GAAA,OAAA,EAAA,QAEA,EAAA,SAAA,EAAA,GACA,GAAA,GAAA,OAIA,MAHA,MAAA,IACA,EAAA,eAEA,GAAA,OAAA,EAAA,EAAA,aAAA,QAEA,EAAA,SAAA,EAAA,GACA,GAAA,GACA,EACA,CACA,KAAA,IAAA,GACA,EAAA,EAAA,GACA,EAAA,EAAA,GACA,IAAA,GACA,EAAA,GAAA,GAEA,EAAA,KAAA,GACA,EAAA,GAAA,GAAA,EAEA,OAAA,IAEA,EAAA,SAAA,EAAA,EAAA,GACA,GAAA,GACA,EACA,EAAA,EAAA,QACA,EAAA,EAAA,QACA,EAAA,EAAA,OACA,EAAA,EAAA,MACA,IA2CA,OA1CA,KAAA,QACA,GAAA,MAEA,EAAA,mBAEA,GAAA,cACA,GAAA,cACA,GAAA,aACA,GAAA,QACA,IAAA,IACA,EAAA,EAAA,OACA,IAAA,UACA,GAAA,OACA,EAAA,EAAA,IAEA,EAAA,EAAA,IAEA,IAAA,IACA,EAAA,EAAA,KAAA,GAAA,IAEA,IAAA,IACA,EAAA,EAAA,UACA,EAAA,EAAA,OAAA,OAAA,EAAA,MAAA,WAAA,IAEA,EAAA,QAAA,WACA,MAAA,IAEA,EAAA,EAAA,GACA,EAAA,UAAA,EACA,EAAA,UAAA,YAAA,EACA,IAAA,GAAA,KAAA,IACA,WACA,GAAA,GAAA,GAAA,EACA,GAAA,WACA,MAAA,IAEA,EAAA,YAAA,WACA,MAAA,OAIA,EAAA,MAAA,GAEA,MAAA,EACA,UAAA,EACA,MAAA,EACA,MAAA,IAMA,GAQA,OAAA,SAAA,EAAA,GACA,GAAA,GAAA,EAAA,EACA,EAAA,UAAA,MACA,QAAA,GACA,IAAA,GACA,EAAA,EAAA,GACA,GACA,EAAA,EAEA,MACA,KAAA,GACA,aAAA,IACA,IAAA,GACA,EAAA,IAAA,QACA,IAAA,GACA,EAAA,EAAA,GACA,IAAA,GACA,EAAA,GAEA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,SAEA,EAAA,EAAA,EAAA,EAAA,EAAA,GAEA,MACA,KAAA,GACA,GAAA,OAAA,EAWA,aADA,GAAA,GACA,CAVA,GAAA,EAAA,QACA,IAAA,IACA,EAAA,EAAA,GACA,IAAA,GACA,EAAA,IAGA,EAAA,EAAA,EAAA,EAAA,EAKA,MACA,SACA,EAAA,SAAA,cAEA,EAAA,GAAA,CACA,MACA,SACA,EAAA,UAEA,MAAA,GAAA,OAQA,MAAA,SAAA,EAAA,SACA,KAAA,GACA,EAAA,QAAA,cAEA,EAAA,GAAA,UAIA,UAAA,EACA,OAAA,SAAA,WAAA,MAAA,WACA,UAAA,EACA,OAAA,IAAA,EAEA,OAAA,QAAA","sourcesContent":["/**\r\n * Created with WebStorm.\r\n * Project: MoaJs\r\n * User: Sergii Danilov\r\n * Date: 10/31/13\r\n * Time: 6:10 PM\r\n */\r\n/*global define:true, module:true*/\r\n/**\r\n Prototype inheritance and extensions in JavaScript\r\n @module Moa\r\n */\r\n(function () {\r\n    \"use strict\";\r\n    if (!Object.create) {\r\n        Object.create = (function () {\r\n            function F() {}\r\n            return function (o) {\r\n                if (arguments.length !== 1) {\r\n                    throw new Error('Object.create implementation only accepts one parameter.');\r\n                }\r\n                F.prototype = o;\r\n                return new F();\r\n            };\r\n        }());\r\n    }\r\n    var undef,\r\n        fn = 'function',\r\n        ob = 'object',\r\n        un = 'undefined',\r\n        map = {},\r\n        mixins = {},\r\n        extend = function (target, source) {\r\n            var prop;\r\n            for (prop in source) {\r\n                if (source.hasOwnProperty(prop)) {\r\n                    target[prop] = source[prop];\r\n                }\r\n            }\r\n            //Some Object methods are not enumerable on Internet Explorer\r\n            target.toString = source.toString;\r\n            target.valueOf = source.valueOf;\r\n            target.toLocaleString = source.toLocaleString;\r\n            return target;\r\n        },\r\n        throwWrongParamsErr = function (method, param) {\r\n            var msg = 'Wrong parameters in ' + method;\r\n            if (param) {\r\n                msg = 'Wrong parameter ' + param + ' in ' + method;\r\n            }\r\n            throw new Error(msg, 'Moa');\r\n        },\r\n        throwWrongType = function (extendType, isMixin) {\r\n            var type = 'Type ';\r\n            if (isMixin === true) {\r\n                type = 'Mixin type ';\r\n            }\r\n            throw new Error(type + extendType + ' not found', 'Moa');\r\n        },\r\n        addMixins = function ($proto, $mixin) {\r\n            var prop,\r\n                value,\r\n                MixFn;\r\n            for (prop in $mixin) {\r\n                value = $mixin[prop];\r\n                MixFn = mixins[value];\r\n                if (MixFn === undef) {\r\n                    throwWrongType(value, true);\r\n                }\r\n                MixFn.call($proto);\r\n                $proto[prop] = new MixFn();\r\n            }\r\n            return $proto;\r\n        },\r\n        build = function (type, base, definition) {\r\n            var basetype,\r\n                $staticMixin,\r\n                $single = definition.$single,\r\n                $static = definition.$static,\r\n                $mixin = definition.$mixin,\r\n                $ctor = definition.$ctor,\r\n                $base = {};\r\n            if ($ctor !== undef) {\r\n                delete definition.$ctor;\r\n            } else {\r\n                $ctor = function () {};\r\n            }\r\n            delete definition.$single;\r\n            delete definition.$static;\r\n            delete definition.$mixin;\r\n            delete definition.$extend;\r\n            if ($static !== undef) {\r\n                $staticMixin = $static.$mixin;\r\n                if ($staticMixin !== undef) {\r\n                    delete $static.$mixin;\r\n                    addMixins($ctor, $staticMixin);\r\n                }\r\n                extend($ctor, $static);\r\n            }\r\n            if ($mixin !== undef) {\r\n                definition = extend(addMixins({}, $mixin), definition);\r\n            }\r\n            if (base !== undef) {\r\n                basetype = base.$basetype;\r\n                definition = extend(Object.create(base.$ctor.prototype), definition);\r\n            }\r\n            definition.getType = function () {\r\n                return type;\r\n            };\r\n            extend($base, definition);\r\n            $ctor.prototype = definition;\r\n            $ctor.prototype.constructor = $ctor;\r\n            if ($single !== undef && $single === true) {\r\n                (function () {\r\n                    var instance = new $ctor();\r\n                    $ctor = function () {\r\n                        return instance;\r\n                    };\r\n                    $ctor.getInstance = function () {\r\n                        return instance;\r\n                    };\r\n                }());\r\n            }\r\n            $base.$ctor = $ctor;\r\n            return {\r\n                $type: type,\r\n                $basetype: basetype,\r\n                $ctor: $ctor,\r\n                $base: $base\r\n            };\r\n        },\r\n        /**\r\n         @class Moa\r\n        */\r\n        Moa = {\r\n            /**\r\n             * Define new or inherited type\r\n             * @method define\r\n             * @param type {string} name of object type\r\n             * @param definition {Object / Function} implementation of behavior for current type of object. If it is null - delete declared object\r\n             * @return {function} constructor of defined object type\r\n             */\r\n            define: function (type, definition) {\r\n                var mapObj, baseType, base,\r\n                    len = arguments.length;\r\n                switch (len) {\r\n                case 1:\r\n                    mapObj = map[type];\r\n                    if (!mapObj) {\r\n                        throwWrongType(type);\r\n                    }\r\n                    break;\r\n                case 2:\r\n                    switch (typeof definition) {\r\n                    case fn:\r\n                        baseType = definition().$extend;\r\n                        if (baseType !== undef) {\r\n                            base = map[baseType];\r\n                            if (base === undef) {\r\n                                throwWrongType(baseType);\r\n                            }\r\n                            mapObj = build(type, base, definition(base.$base));\r\n                        } else {\r\n                            mapObj = build(type, undef, definition(undef));\r\n                        }\r\n                        break;\r\n                    case ob:\r\n                        if (definition !== null) {\r\n                            baseType = definition.$extend;\r\n                            if (baseType !== undef) {\r\n                                base = map[baseType];\r\n                                if (base === undef) {\r\n                                    throwWrongType(baseType);\r\n                                }\r\n                            }\r\n                            mapObj = build(type, base, definition);\r\n                        } else {\r\n                            delete map[type];\r\n                            return undef;\r\n                        }\r\n                        break;\r\n                    default:\r\n                        throwWrongParamsErr('define', 'definition');\r\n                    }\r\n                    map[type] = mapObj;\r\n                    break;\r\n                default:\r\n                    throwWrongParamsErr('define');\r\n                }\r\n                return mapObj.$ctor;\r\n            },\r\n            /**\r\n             * Declare new mixin type\r\n             * @method mixin\r\n             * @param mixType {string} name of mixin type\r\n             * @param definition {Function} implementation of behavior for mixin.\r\n             */\r\n            mixin: function (mixType, definition) {\r\n                if (typeof definition !== fn) {\r\n                    throwWrongParamsErr('mixin', 'definition');\r\n                }\r\n                mixins[mixType] = definition;\r\n            }\r\n        };\r\n    // Return as AMD module or attach to head object\r\n    if (typeof define !== un) {\r\n        define('Moa',[], function () { return Moa; });\r\n    } else if (typeof window !== un) {\r\n        window.Moa = Moa;\r\n    } else {\r\n        module.exports = Moa;\r\n    }\r\n}());\n"]}