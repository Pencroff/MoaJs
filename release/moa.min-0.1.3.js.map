/*********************************************
   The MIT License (MIT)
   Copyright (c) 2013 - 2014 Sergii Danilov
   MoaJs - v0.1.3 - 2014-03-23
*********************************************/
{"version":3,"file":"moa.min.js","sources":["Moa.js"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * Created with WebStorm.\r\n * Project: MoaJs\r\n * User: Sergii Danilov\r\n * Date: 10/31/13\r\n * Time: 6:10 PM\r\n */\r\n/*global define:true, module:true*/\r\n/**\r\n Prototype inheritance and extensions in JavaScript\r\n @module Moa\r\n */\r\n(function () {\r\n    \"use strict\";\r\n    if (!Object.create) {\r\n        Object.create = (function () {\r\n            function F() {}\r\n            return function (o) {\r\n                if (arguments.length !== 1) {\r\n                    throw new Error('Object.create implementation only accepts one parameter.');\r\n                }\r\n                F.prototype = o;\r\n                return new F();\r\n            };\r\n        }());\r\n    }\r\n    var undef,\r\n        map = {},\r\n        mixins = {},\r\n        extend = function (target, source) {\r\n            var prop;\r\n            if (source) {\r\n                for (prop in source) {\r\n                    if (source.hasOwnProperty(prop)) {\r\n                        target[prop] = source[prop];\r\n                    }\r\n                }\r\n                //Some Object methods are not enumerable on Internet Explorer\r\n                target.toString = source.toString;\r\n                target.valueOf = source.valueOf;\r\n                target.toLocaleString = source.toLocaleString;\r\n            }\r\n            return target;\r\n        },\r\n        throwWrongParamsErr = function (method, param) {\r\n            var msg = 'Wrong parameters in ' + method;\r\n            if (param) {\r\n                msg = 'Wrong parameter ' + param + ' in ' + method;\r\n            }\r\n            throw new Error(msg, 'Moa');\r\n        },\r\n        throwWrongType = function (obj, extendType, isMixin) {\r\n            var type = 'Type ';\r\n            if (obj === undef) {\r\n                if (isMixin === true) {\r\n                    type = 'Mixin type ';\r\n                }\r\n                throw new Error(type + extendType + ' not found', 'Moa');\r\n            }\r\n        },\r\n        addMixins = function ($proto, $mixin) {\r\n            var prop,\r\n                value,\r\n                MixFn;\r\n            for (prop in $mixin) {\r\n                value = $mixin[prop];\r\n                MixFn = mixins[value];\r\n                throwWrongType(MixFn, value, true);\r\n                MixFn.call($proto);\r\n                $proto[prop] = new MixFn();\r\n            }\r\n            return $proto;\r\n        },\r\n        build = function (type, base, definition) {\r\n            var basetype,\r\n                $staticMixin,\r\n                $single = definition.$single,\r\n                $static = definition.$static,\r\n                $mixin = definition.$mixin,\r\n                $ctor = definition.$ctor,\r\n                $di = definition.$di,\r\n                $base = {};\r\n            if ($ctor !== undef) {\r\n                delete definition.$ctor;\r\n            } else {\r\n                $ctor = function () {};\r\n            }\r\n            delete definition.$single;\r\n            delete definition.$static;\r\n            delete definition.$mixin;\r\n            delete definition.$extend;\r\n            if ($static !== undef) {\r\n                $staticMixin = $static.$mixin;\r\n                if ($staticMixin !== undef) {\r\n                    delete $static.$mixin;\r\n                    addMixins($ctor, $staticMixin);\r\n                }\r\n                extend($ctor, $static);\r\n            }\r\n            if ($mixin !== undef) {\r\n                definition = extend(addMixins({}, $mixin), definition);\r\n            }\r\n            if (base !== undef) {\r\n                basetype = base.$type;\r\n                definition = extend(Object.create(base.$ctor.prototype), definition);\r\n            }\r\n            definition.getType = function () {\r\n                return type;\r\n            };\r\n            extend($base, definition);\r\n            $ctor.prototype = definition;\r\n            $ctor.prototype.constructor = $ctor;\r\n            if ($single !== undef && $single === true) {\r\n                (function () {\r\n                    var instance = new $ctor();\r\n                    $ctor = function () {\r\n                        return instance;\r\n                    };\r\n                    $ctor.getInstance = function () {\r\n                        return instance;\r\n                    };\r\n                }());\r\n            }\r\n            $base.$ctor = $ctor;\r\n            return {\r\n                $type: type,\r\n                $basetype: basetype,\r\n                $mixin: $mixin,\r\n                $di: $di,\r\n                $ctor: $ctor,\r\n                $base: $base\r\n            };\r\n        },\r\n        resolveDeclaration = function (type, diConfiguration) {\r\n            var configurationProperty, configurationValue, typeObj;\r\n            diConfiguration = diConfiguration || {};\r\n            if (!diConfiguration.$current) {\r\n                diConfiguration.$current = type;\r\n            }\r\n            for (configurationProperty in diConfiguration) {\r\n                if (configurationProperty === '$ctor') {\r\n                    configurationValue = resolveDeclaration(type, diConfiguration[configurationProperty]);\r\n                    delete configurationValue.$current;\r\n                } else {\r\n                    configurationValue = diConfiguration[configurationProperty];\r\n                    switch (typeof configurationValue) {\r\n                    case 'string':\r\n                        if (configurationProperty === '$current') {\r\n                            configurationValue = {\r\n                                type: configurationValue,\r\n                                instance: 'item',\r\n                                lifestyle: 'transient'\r\n                            };\r\n                        } else {\r\n                            typeObj = map[configurationValue];\r\n                            if (typeObj) {\r\n                                configurationValue = typeObj.$di.$current;\r\n                            }\r\n                        }\r\n                        break;\r\n                    case 'object':\r\n                        if (configurationProperty === '$current') {\r\n                            configurationValue.type = type;\r\n                        }\r\n                        if (configurationValue.type) {\r\n                            if (configurationValue.instance === 'ctor') {\r\n                                delete configurationValue.lifestyle;\r\n                            } else {\r\n                                if (!configurationValue.instance) {\r\n                                    configurationValue.instance = 'item';\r\n                                }\r\n                                if (!configurationValue.lifestyle) {\r\n                                    configurationValue.lifestyle = 'transient';\r\n                                }\r\n                            }\r\n                        }\r\n                        break;\r\n                    default:\r\n                    }\r\n                }\r\n                diConfiguration[configurationProperty] = configurationValue;\r\n            }\r\n            return diConfiguration;\r\n        },\r\n        /**\r\n         @class Moa\r\n        */\r\n        Moa = {\r\n            /**\r\n             * Define new or inherited type\r\n             * @method define\r\n             * @param type {string} name of object type\r\n             * @param definition {Object / Function} implementation of behavior for current type of object. If it is null - delete declared object\r\n             * @return {function} constructor of defined object type\r\n             */\r\n            clear: function () {\r\n                var clearObj = function (obj) {\r\n                    var prop;\r\n                    for (prop in obj) {\r\n                        delete obj[prop];\r\n                    }\r\n                };\r\n                clearObj(map);\r\n                clearObj(mixins);\r\n            },\r\n            define: function (type, definition) {\r\n                var mapObj, baseType, base,\r\n                    len = arguments.length;\r\n                switch (len) {\r\n                case 1:\r\n                    mapObj = map[type];\r\n                    throwWrongType(mapObj, type);\r\n                    break;\r\n                case 2:\r\n                    switch (typeof definition) {\r\n                    case 'function':\r\n                        baseType = definition().$extend;\r\n                        if (baseType !== undef) {\r\n                            base = map[baseType];\r\n                            throwWrongType(base, baseType);\r\n                            mapObj = build(type, base, definition(base.$base));\r\n                        } else {\r\n                            mapObj = build(type, undef, definition(undef));\r\n                        }\r\n                        break;\r\n                    case 'object':\r\n                        if (definition !== null) {\r\n                            baseType = definition.$extend;\r\n                            if (baseType !== undef) {\r\n                                base = map[baseType];\r\n                                throwWrongType(base, baseType);\r\n                            }\r\n                            mapObj = build(type, base, definition);\r\n                        } else {\r\n                            delete map[type];\r\n                            return undef;\r\n                        }\r\n                        break;\r\n                    default:\r\n                        throwWrongParamsErr('define', 'definition');\r\n                    }\r\n                    map[type] = mapObj;\r\n                    map[type].$di = resolveDeclaration(type, mapObj.$di);\r\n                    break;\r\n                default:\r\n                    throwWrongParamsErr('define');\r\n                }\r\n                return mapObj.$ctor;\r\n            },\r\n            resolve: function (type, configObj) {\r\n                var item,\r\n                    //depthRecursion = 64, cntRecursion = 0,\r\n                    mapObj = map[type],\r\n                    len = arguments.length,\r\n                    createItem = function (mObj, cParams, cObj) {\r\n                        var item;\r\n                        if (cParams) {\r\n                            cParams = extend(cParams, cObj);\r\n                            item = new mObj.$ctor(cParams);\r\n                        } else {\r\n                            item = new mObj.$ctor(cObj);\r\n                        }\r\n                        return item;\r\n                    },\r\n                    fnResolveObjConf = function (declaration, fnResolveListConf, mp, ctorParams) {\r\n                        var resolvedObj, ctorDiObj, propDiObj, ctorDiConf, propDiConf,\r\n                            current = declaration.$current;\r\n/*================================================================================\r\n                        if you have problem with IoC, just uncomment 3 rows bellow\r\n                        and second row in 'resolve' function\r\n ================================================================================*/\r\n\r\n//                        cntRecursion += 1;\r\n//                        if (cntRecursion > depthRecursion) {\r\n//                            throw new Error('Loop of recursion', 'moa');\r\n//                        }\r\n                        if (current) {\r\n                            resolvedObj = mp[current.type];\r\n                            ctorDiConf = declaration.$ctor;\r\n                            propDiConf = declaration;\r\n                        } else {\r\n                            current = declaration;\r\n                            resolvedObj = mp[current.type];\r\n                            if (resolvedObj) {\r\n                                ctorDiConf = resolvedObj.$di.$ctor;\r\n                                propDiConf = resolvedObj.$di;\r\n                            } else {\r\n                                return declaration;\r\n                            }\r\n                        }\r\n                        switch (current.instance) {\r\n                        case 'item':\r\n                            if (ctorDiConf) {\r\n                                ctorDiObj = fnResolveListConf(ctorDiConf, fnResolveObjConf, mp);\r\n                            }\r\n                            propDiObj = fnResolveListConf(propDiConf, fnResolveObjConf, mp);\r\n                            switch (current.lifestyle) {\r\n                            case 'transient':\r\n                                item = createItem(resolvedObj, ctorParams, ctorDiObj);\r\n                                break;\r\n                            case 'singleton':\r\n                                if (!current.item) {\r\n                                    current.item = createItem(resolvedObj, ctorParams, ctorDiObj);\r\n                                }\r\n                                item = current.item;\r\n                                break;\r\n                            default:\r\n                                throwWrongParamsErr('resolve', type + '::$di::$current::lifestyle');\r\n                            }\r\n                            break;\r\n                        case 'ctor':\r\n                            item = resolvedObj.$ctor;\r\n                            break;\r\n                        default:\r\n                            throwWrongParamsErr('resolve', type + '::$di::$current::instance');\r\n                        }\r\n                        if (propDiObj) {\r\n                            item = extend(item, propDiObj);\r\n                        }\r\n                        return item;\r\n                    },\r\n                    fnResolveListConf = function (objDeclaration, fnResolveObjConf, mp) {\r\n                        var prop, propValue, mpObj,\r\n                            result = {};\r\n                        for (prop in objDeclaration) {\r\n                            if (prop !== '$current' && prop !== '$ctor') {\r\n                                propValue = objDeclaration[prop];\r\n                                if (typeof propValue === 'object') {\r\n                                    result[prop] = fnResolveObjConf(propValue, fnResolveListConf, mp);\r\n                                } else {\r\n                                    result[prop] = propValue;\r\n                                }\r\n                            }\r\n                        }\r\n                        return result;\r\n                    };\r\n                if (len !== 1 && len !== 2) {\r\n                    throwWrongParamsErr('resolve');\r\n                }\r\n                throwWrongType(mapObj, type);\r\n                item = fnResolveObjConf(mapObj.$di, fnResolveListConf, map, configObj);\r\n                return item;\r\n            },\r\n            /**\r\n             * Declare new mixin type\r\n             * @method mixin\r\n             * @param mixType {string} name of mixin type\r\n             * @param definition {Function} implementation of behavior for mixin.\r\n             */\r\n            mixin: function (mixType, definition) {\r\n                if (definition !== null) {\r\n                    if (typeof definition !== 'function') {\r\n                        throwWrongParamsErr('mixin', 'definition');\r\n                    }\r\n                    mixins[mixType] = definition;\r\n                } else {\r\n                    delete mixins[mixType];\r\n                }\r\n            },\r\n            /**\r\n             * Return object with lists of types and mixins\r\n             * @method getRegistry\r\n             */\r\n            getRegistry: function () {\r\n                var iterate = function (obj) {\r\n                        var prop, arr = [];\r\n                        for (prop in obj) {\r\n                            arr.push(prop);\r\n                        }\r\n                        return arr;\r\n                    };\r\n                return {\r\n                    type: iterate(map),\r\n                    mixin: iterate(mixins)\r\n                };\r\n            },\r\n            getTypeInfo: function (type) {\r\n                var result,\r\n                    mapObj = map[type];\r\n                throwWrongType(mapObj, type);\r\n                result = extend({}, mapObj);\r\n                delete result.$ctor;\r\n                delete result.$base;\r\n                delete result.$di;\r\n                result.$di = JSON.parse(JSON.stringify(mapObj.$di));\r\n                return result;\r\n            }\r\n        };\r\n    // Return as AMD module or attach to head object\r\n    if (typeof define !== 'undefined') {\r\n        define('Moa',[], function () { return Moa; });\r\n    } else if (typeof window !== 'undefined') {\r\n        window.Moa = Moa;\r\n    } else {\r\n        module.exports = Moa;\r\n    }\r\n}());\n"]}